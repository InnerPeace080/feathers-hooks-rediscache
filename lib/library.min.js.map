{"version":3,"sources":["webpack://library/webpack/universalModuleDefinition","webpack://library/webpack/bootstrap","webpack://library/./src/routes/helpers/redis.js","webpack://library/./src/index.js","webpack://library/./src/routes/cache.js","webpack://library/external \"express\"","webpack://library/./src/redisClient.js","webpack://library/external \"redis\"","webpack://library/./src/hooks/cache.js","webpack://library/./src/hooks/redis.js","webpack://library/external \"moment\"","webpack://library/external \"chalk\"","webpack://library/./src/hooks/helpers/path.js"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","RedisCache","client","_classCallCheck","this","_this","Promise","resolve","reject","del","err","reply","_this2","lrange","clearAll","then","e","array","_this3","length","clearSingle","_cache3","_redis","redisClient","cacheRoutes","hookCache","hookRemoveCacheInformation","redisBeforeHook","redisAfterHook","redisClearGroupHook","HTTP_OK","HTTP_NO_CONTENT","HTTP_SERVER_ERROR","app","router","express","Router","h","req","res","target","params","query","hasQueryString","keys","url","split","status","json","message","Array","isArray","clearGroup","require","set","redis","createClient","cache","options","assign","defaults","hook","result","wrapped","duration","removeCacheInformation","before","cacheOptions","env","path","_path","parsePath","pathForRedisCache","data","JSON","parse","_moment2","default","expiresOn","format","console","log","chalk","cyan","green","after","cached","cachingDefault","defaultDuration","add","moment","parent","group","stringify","expire","rpush","humanize","targetTemp","config","arguments","undefined","removePathFromCacheKey","parseNestedRoutes","q","remove","id","re","RegExp","match","exec","route","includes","replace","parseNestedPath"],"mappings":"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","file":"library.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"library\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"library\"] = factory();\n\telse\n\t\troot[\"library\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","export default class RedisCache {\n  constructor(client) {\n    this.client = client;\n  }\n\n  /**\n   * scan the redis index\n   */\n  // scan() {\n  //   // starts at 0 if cursor is again 0 it means the iteration is finished\n  //   let cursor = '0';\n\n  //   return new Promise((resolve, reject) => {\n  //     this.client.scan(cursor, 'MATCH', '*', 'COUNT', '100', (err, reply) => {\n  //       if (err) {\n  //         reject(err);\n  //       }\n\n  //       cursor = reply[0];\n  //       if (cursor === '0') {\n  //         resolve(reply[1]);\n  //       } else {\n  //         // do your processing\n  //         // reply[1] is an array of matched keys.\n  //         // console.log(reply[1]);\n  //         return this.scan();\n  //       }\n  //       return false;\n  //     });\n\n  //   });\n  // }\n\n  /**\n   * Async scan of the redis index\n   * Do not for get to passin a Set\n   * myResults = new Set();\n   *\n   * scanAsync('0', \"NOC-*[^listen]*\", myResults).map(\n   *   myResults => { console.log( myResults); }\n   * );\n   *\n   * @param {String} cursor - string '0'\n   * @param {String} patern - string '0'\n   * @param {Set} returnSet - pass a set to have unique keys\n   */\n  // scanAsync(cursor, pattern, returnSet) {\n  //   // starts at 0 if cursor is again 0 it means the iteration is finished\n\n  //   return new Promise((resolve, reject) => {\n  //     this.client.scan(cursor, 'MATCH', pattern, 'COUNT', '100', (err, reply) => {\n\n  //       if (err) {\n  //         reject(err);\n  //       }\n\n  //       cursor = reply[0];\n  //       const keys = reply[1];\n\n  //       keys.forEach((key, i) => {\n  //         returnSet.add(key);\n  //       });\n\n  //       if (cursor === '0') {\n  //         resolve(Array.from(returnSet));\n  //       }\n\n  //       return this.scanAsync(cursor, pattern, returnSet);\n  //     });\n  //   });\n  // }\n\n  /**\n   * Clean single item from the cache\n   * @param {string} key - the key to find in redis\n   */\n  clearSingle(key) {\n    return new Promise((resolve, reject) => {\n      this.client.del(`${key}`, (err, reply) => {\n        if (err) reject(false);\n        if (reply === 1) {\n          resolve(true);\n        }\n        resolve(false);\n      });\n    });\n  }\n\n  /**\n   * Clear a group\n   * @param {string} key - key of the group to clean\n   */\n  clearGroup(key) {\n    return new Promise((resolve, reject) => {\n      this.client.lrange(key, 0, -1, (err, reply) => {\n        if (err) {\n          reject(err);\n        }\n        this.clearAll(reply).then(\n          this.client.del(key, (e, r) => {\n            resolve(r === 1);\n          })\n        );\n      });\n    });\n  }\n\n  /**\n   * Clear all keys of a redis list\n   * @param {Object[]} array\n   */\n  clearAll(array) {\n    return new Promise(resolve => {\n      if (!array.length) resolve(false);\n      let i = 0;\n\n      for (i; i < array.length; i++) {\n        this.clearSingle(array[i]).then(r => {\n          if (i === array.length - 1) {\n            resolve(r);\n          }\n        });\n      }\n    });\n  }\n};\n","import cacheRoutes from './routes/cache';\nimport redisClient from './redisClient';\nimport { cache as hookCache } from './hooks/cache';\nimport { removeCacheInformation as hookRemoveCacheInformation } from './hooks/cache';\nimport { before as redisBeforeHook} from './hooks/redis';\nimport { after as redisAfterHook} from './hooks/redis';\nimport { clearGroup as redisClearGroupHook} from './hooks/redis';\n\nexport default {\n  redisClient,\n  cacheRoutes,\n  hookCache,\n  hookRemoveCacheInformation,\n  redisBeforeHook,\n  redisAfterHook,\n  redisClearGroupHook\n};\n","import express from 'express';\n\nimport RedisCache from './helpers/redis';\n\nconst HTTP_OK = 200;\nconst HTTP_NO_CONTENT = 204;\nconst HTTP_SERVER_ERROR = 500;\n\nfunction routes(app) {\n  const router = express.Router();\n  const client = app.get('redisClient');\n  const h = new RedisCache(client);\n\n  router.get('/clear', (req, res) => {\n    // client.flushall();\n    // res.status(HTTP_OK).json({\n    //   message: 'Cache cleared',\n    //   status: HTTP_OK\n    // });\n  });\n\n  // clear a unique route\n  router.get('/clear/single/:target', (req, res) => {\n    let target = req.params.target;\n    // Formated options following ?\n    const query = req.query;\n    const hasQueryString = (query && (Object.keys(query).length !== 0));\n\n    // Target should always be defined as Express router raises 404\n    // as route is not handled\n    if (target) {\n      if (hasQueryString) {\n      // Keep queries in a single string with the taget\n        target = req.url.split('/')[3];\n      }\n\n      // Gets the value of a key in the redis client\n      client.get(`cache:${target}`, (err, reply) => {\n        if (err) {\n          res.status(HTTP_SERVER_ERROR).json({\n            message: 'something went wrong' + err.message\n          });\n        } else {\n          // If the key existed\n          if (reply) {\n            // Clear existing cached key\n            h.clearSingle(`cache:${target}`).then(r => {\n              res.status(HTTP_OK).json({\n                message: `cache cleared for key (${hasQueryString ?\n                  'with' : 'without'} params): ${target}`,\n                status: HTTP_OK\n              });\n            });\n          } else {\n            /**\n             * Empty reply means the key does not exist.\n             * Must use HTTP_OK with express as HTTP's RFC stats 204 should not\n             * provide a body, message would then be lost.\n             */\n            res.status(HTTP_OK).json({\n              message: `cache already cleared for key (${hasQueryString ?\n                'with' : 'without'} params): ${target}`,\n              status: HTTP_NO_CONTENT\n            });\n          }\n\n        }\n      });\n    }\n  });\n\n  // clear a group\n  router.get('/clear/group/:target', (req, res) => {\n    let target = req.params.target;\n\n    // Target should always be defined as Express router raises 404\n    // as route is not handled\n    if (target) {\n      target = 'group-' + target;\n      // Returns elements of the list associated to the target/key 0 being the\n      // first and -1 specifying get all till the latest\n      client.lrange(`cache:${target}`, 0, -1, (err, reply) => {\n        if (err) {\n          res.status(HTTP_SERVER_ERROR).json({\n            message: 'something went wrong' + err.message\n          });\n        } else {\n          // If the list/group existed and contains something\n          if (reply && Array.isArray(reply) && (reply.length > 0)) {\n            // Clear existing cached group key\n            h.clearGroup(`cache:${target}`).then(r => {\n              res.status(HTTP_OK).json({\n                message:\n                  `cache cleared for the group key: ${req.params.target}`,\n                status: HTTP_OK\n              });\n            });\n          } else {\n            /**\n             * Empty reply means the key does not exist.\n             * Must use HTTP_OK with express as HTTP's RFC stats 204 should not\n             * provide a body, message would then be lost.\n             */\n            res.status(HTTP_OK).json({\n              message:\n                `cache already cleared for the group key: ${target}`,\n              status: HTTP_NO_CONTENT\n            });\n          }\n        }\n      });\n    }\n  });\n\n  // add route to display cache index\n  // this has been removed for performance issues\n  // router.get('/index', (req, res) => {\n  //   let results = new Set();\n\n  //   h.scanAsync('0', '*', results)\n  //     .then(data => {\n  //       res.status(200).json(data);\n  //     })\n  //     .catch(err => {\n  //       res.status(404).json(err);\n  //     });\n\n  // });\n\n  return router;\n}\n\nexport default routes;\n","module.exports = require(\"express\");","import redis from 'redis';\n\nexport default function redisClient() { // eslint-disable-line no-unused-vars\n  this.set('redisClient', redis.createClient(this.get('redis')));\n  return this;\n}\n","module.exports = require(\"redis\");","/**\n * After hook - generates a cache object that is needed\n * for the redis hook and the express middelware.\n * @todo add default value in config file\n */\nconst defaults = {};\n\nexport function cache(options) { // eslint-disable-line no-unused-vars\n  options = Object.assign({}, defaults, options);\n\n  return function (hook) {\n    if (!hook.result.hasOwnProperty('cache')) {\n      let cache = {};\n\n      if (Array.isArray(hook.result)) {\n        const array = hook.result;\n\n        cache.wrapped = array;\n        hook.result = {};\n      }\n\n      cache = Object.assign({}, cache, {\n        // cached: false,\n        duration: options.duration || 3600 * 24\n      });\n\n      hook.result.cache = cache;\n    }\n    return Promise.resolve(hook);\n  };\n};\n\nexport function removeCacheInformation(options) { // eslint-disable-line no-unused-vars\n  options = Object.assign({}, defaults, options);\n\n  return function (hook) {\n    if (hook.result.hasOwnProperty('cache')) {\n      delete hook.result.cache;\n    }\n    return Promise.resolve(hook);\n  };\n};\n","import moment from 'moment';\nimport chalk from 'chalk';\nimport { parsePath } from './helpers/path';\nimport RedisCache from '../routes/helpers/redis';\n\nconst defaults = {};\n\nexport function before(options) { // eslint-disable-line no-unused-vars\n  options = Object.assign({}, defaults, options);\n\n  return function (hook) {\n    return new Promise(resolve => {\n      const client = hook.app.get('redisClient');\n      const cacheOptions = hook.app.get('redisCache');\n      const env = cacheOptions.env || 'production';\n      const path = parsePath(hook, cacheOptions);\n\n      hook.pathForRedisCache = path;\n      client.get(`cache:${path}`, (err, reply) => {\n        if (err !== null) {resolve(hook); return;}\n        if (reply) {\n          let data = JSON.parse(reply);\n\n          if (!data.cache) {\n            resolve(hook);\n            return;\n          }\n          const duration = moment(data.cache.expiresOn).format('DD MMMM YYYY - HH:mm:ss');\n\n          hook.result = data;\n          resolve(hook);\n\n          /* istanbul ignore next */\n          if (env !== 'test') {\n            console.log(`${chalk.cyan('[redis]')} returning cached value for ${chalk.green(path)}.`);\n            console.log(`> Expires on ${duration}.`);\n          }\n        } else {\n          resolve(hook);\n          return;\n        }\n      });\n    });\n  };\n};\n\nexport function after(options) { // eslint-disable-line no-unused-vars\n  options = Object.assign({}, defaults, options);\n\n  return function (hook) {\n    return new Promise(resolve => {\n      if ((!hook.result) || (!hook.result.cache) || (!hook.result.cache.cached)) {\n        const cacheOptions = hook.app.get('redisCache');\n        const env = cacheOptions.env || 'production';\n        const cachingDefault = cacheOptions.defaultDuration ? cacheOptions.defaultDuration : 3600 * 24;\n        const duration = (hook.result && hook.result.cache) ?\n          hook.result.cache.duration : cachingDefault;\n        const client = hook.app.get('redisClient');\n        const path = (hook.pathForRedisCache || parsePath(hook, cacheOptions));\n\n        // adding a cache object\n        hook.result.cache = Object.assign(hook.result.cache || {}, {\n          cached: true,\n          duration: duration,\n          expiresOn: moment().add(moment.duration(duration, 'seconds')),\n          parent: hook.path,\n          group: hook.path ? `group-${hook.path}` : '',\n          key: path\n        });\n\n        client.set(`cache:${path}`, JSON.stringify(hook.result));\n        client.expire(`cache:${path}`, hook.result.cache.duration);\n        if (hook.path) {\n          client.rpush(`cache:${hook.result.cache.group}`, `cache:${path}`);\n        }\n\n        /* istanbul ignore next */\n        if (env !== 'test') {\n          console.log(`${chalk.cyan('[redis]')} added ${chalk.green(path)} to the cache.`);\n          console.log(`> Expires in ${moment.duration(duration, 'seconds').humanize()}.`);\n        }\n      }\n\n      if (hook.result && hook.result.cache && hook.result.cache.hasOwnProperty('wrapped')) {\n        const { wrapped } = hook.result.cache;\n\n        hook.result = wrapped;\n      }\n\n      resolve(hook);\n    });\n  };\n};\n\nexport function clearGroup(target) { // eslint-disable-line no-unused-vars\n  return function (hook) {\n    let targetTemp = target || hook.path;\n\n    if (targetTemp) {\n      const client = hook.app.get('redisClient');\n      const h = new RedisCache(client);\n\n      targetTemp = 'group-' + targetTemp;\n      // Returns elements of the list associated to the target/key 0 being the\n      // first and -1 specifying get all till the latest\n      client.lrange(`cache:${targetTemp}`, 0, -1, (err, reply) => {\n        if (err) {\n          console.log({\n            message: 'something went wrong' + err.message\n          });\n        } else {\n          // If the list/group existed and contains something\n          if (reply && Array.isArray(reply) && (reply.length > 0)) {\n            // Clear existing cached group key\n            h.clearGroup(`cache:${targetTemp}`).then(r => {\n              console.log({\n                message:\n                  `cache cleared for the group key: ${targetTemp}`\n              });\n            });\n          } else {\n            /**\n             * Empty reply means the key does not exist.\n             * Must use HTTP_OK with express as HTTP's RFC stats 204 should not\n             * provide a body, message would then be lost.\n             */\n            console.log({\n              message:\n               `cache already cleared for the group key: ${targetTemp}`\n            });\n          }\n        }\n      });\n    }\n  };\n};\n","module.exports = require(\"moment\");","module.exports = require(\"chalk\");","// import qs from 'qs';\n\nfunction parseNestedPath(path, params) {\n  const re = new RegExp(':([^\\\\/\\\\?]+)\\\\??', 'g');\n  let match = null;\n\n  while ((match = re.exec(path)) !== null) {\n    if (Object.keys(params.route).includes(match[1])) {\n      path = path.replace(match[0], params.route[match[1]]);\n    }\n  }\n\n  return path;\n}\n\nfunction parsePath(hook, config = {removePathFromCacheKey: false, parseNestedRoutes: false}) {\n  const q = hook.params.query || {};\n  const remove = config.removePathFromCacheKey;\n  const parseNestedRoutes = config.parseNestedRoutes;\n  let path = remove && hook.id ? '' : `${hook.path}`;\n\n  if (!remove && parseNestedRoutes) {\n    path = parseNestedPath(path, hook.params);\n  }\n\n  if (hook.id) {\n    if (path.length !== 0 && !remove) {\n      path += '/';\n    }\n    if (Object.keys(q).length > 0) {\n      // path += `${hook.id}?${qs.stringify(q, { encode: false })}`;\n      path += `${hook.id}?${JSON.stringify(q)}`;\n    } else {\n      path += `${hook.id}`;\n    }\n  } else {\n    if (Object.keys(q).length > 0) {\n      // path += `?${qs.stringify(q, { encode: false })}`;\n      path += `?${JSON.stringify(q)}`;\n    }\n  }\n\n  return path;\n}\n\nexport { parsePath };\n"],"sourceRoot":""}